<!DOCTYPE html>
<html>
<head>
<title>Marine Compass</title>

<meta charset="utf-8">
<meta name="viewport" content="user-scalable=no, initial-scale=1">

<style>
  html {
    width: 100%;
    height: 100%;
  }
  body {
    position: fixed;
    margin: 0px;
    padding: 0px;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: transparent url(./images/bg.jpg) no-repeat scroll 50%;
    background-size: 100% 100%;
    font-family: Arial, Helvetica, sans-serif;
  }
  #glCanvas {
    position: absolute;
    pointer-events: none;
    top: 0;
  }
  .output_err {
    display: block;
    background-color: #fff;
    color: #CC0000;
    font-weight: bold;
    border: 1px solid #000;
    margin: 20px 10px;
    padding: 20px;
  }
  .heading {
    display: block;
    text-align: center;
    padding: 10px 0 0;
    height: 40px;
    color: #fff;
    font-size: 1.8em;
    font-weight: normal;
  }
  button {
    padding: 8px;
    margin: 6px 8px 6px 8px;
    font: 500 16px Roboto, sans-serif;
    color: #039be5;
    background-color: transparent;
    border: 0;
    border-radius: 2px;
    box-shadow: none;
    cursor: pointer;
    display: inline-block;
    height: 36px;
    min-width: 36px;
    outline: 0;
    overflow: hidden;
    text-align: center;
    text-decoration: none;
    text-overflow: ellipsis;
    text-transform: uppercase;
    transition: background-color .2s,box-shadow .2s;
    vertical-align: middle;
    white-space: nowrap;
  }
</style>

<!-- COMPASS -->
<script type="text/javascript" src="scripts/gl-matrix.min.js"></script>
<script type="text/javascript" src="scripts/compass.js"></script>

<script src="scripts/custom-elements.min.js" defer></script>

<link rel="manifest" href="/manifest.json">
<link rel="serviceworker" href="/sw.js">

<template id="menu-drawer">
  <style>
    :host {
      touch-action: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    :host::before {
      content: '';
      display: block;
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.4);
      opacity: 0;
      will-change: opacity;
      transition: opacity 0.3s cubic-bezier(0,0,0.3,1);
    }
    .container {
      position: relative;
      width: 90%;
      max-width: 400px;
      background: #FFF;
      height: 100%;
      box-shadow: 2px 0 12px rgba(0,0,0,0.4);
      transform: translateX(-102%);
      display: flex;
      flex-direction: column;
      will-change: transform;
    }
    .animation {
      transition: transform 0.33s cubic-bezier(0,0,0.3,1);
    }
    .expanded {
      transform: none;
    }
    .content {
      margin: 10px;
    }

  </style>
  <div class="container">
    <div class="content">
      <slot></slot>
    </div>
  </div>
</template>

<script>
  // Should:
  // - allow being swiped in from the left
  // - on touch end, if majority of menu is visible, animate the rest in, else animate out
  // - allow being swiped out from the right, if open (from the point on it touches)
  // - click outside, closes menu
  // - inertia should close and open depending on direction (so-called fling)
  customElements.define('menu-drawer', class extends HTMLElement {
    constructor() {
      super();

      const template = document.querySelector('#menu-drawer');
      const clone = document.importNode(template.content, true);

      const shadowRoot = this.attachShadow({ mode: 'open' });
      shadowRoot.appendChild(clone);

      this.determineTouchStart = this.determineTouchStart.bind(this);
      this.onTouchStart = this.onTouchStart.bind(this);
      this.onTouchMove = this.onTouchMove.bind(this);
      this.onTouchEnd = this.onTouchEnd.bind(this);
      this.onTransitionEnd = this.onTransitionEnd.bind(this);
      this.update = this.update.bind(this);

      this._startX = 0;
      this._currentX = 0;
      this._dX = 0;
      this._touching = false;
      this._opened = false;
    }

    connectedCallback() {
      this.containerEl = this.shadowRoot.querySelector('.container');

      this.addEventListener('pointerdown', this.determineTouchStart, { passive: true });
      this.addEventListener('pointermove', this.onTouchMove, { passive: true });
      this.addEventListener('pointerup', this.onTouchEnd);
    }

    get opened() {
      return this._opened;
    }

    set opened(value) {
      this.containerEl.addEventListener('transitionend', this.onTransitionEnd);
      this.containerEl.classList.add('animation');

      this._opened = value;
      if (value) {
        this.containerEl.classList.add('expanded');
      } else {
        this.containerEl.classList.remove('expanded');
      }
    }

    onTransitionEnd (evt) {
      this.containerEl.classList.remove('animation');
      this.containerEl.removeEventListener('transitionend', this.onTransitionEnd);
    }

    determineTouchStart(evt) {
      // Allow a few pixels from the left as start region.
      if (evt.pageX < 20 || this.shadowRoot.elementsFromPoint(evt.pageX, evt.pageY).includes(this.containerEl))
        this.onTouchStart(evt);
    }

    onTouchStart(evt) {
      this._touching = true;

      this._left = this.containerEl.getBoundingClientRect().left;

      this._startX = evt.pageX;
      this._currentX = this._startX;

      requestAnimationFrame(this.update);
    }

    onTouchMove(evt) {
      if (!this._touching) {
        this.determineTouchStart(evt);
        return;
      }

      this._dX = evt.pageX - this._currentX;
      this._currentX = evt.pageX;
    }

    onTouchEnd(evt) {
      if (!this._touching) {
        this.opened = false;
        return;
      }

      this._touching = false;

      let endOpenedState;

      // Check for fling.
      if (Math.abs(this._dX) > 10) {
        endOpenedState = this._dX > 0;
      }
      // Check depending on percentage visible.
      else {
        let left = this.containerEl.getBoundingClientRect().left;
        let width = this.containerEl.clientWidth;
        let percentageVisible = (left + width) / width
        endOpenedState = percentageVisible >= 0.5;
      }

      this.containerEl.style.transform = '';
      this.opened = endOpenedState;
    }

    update() {
      if (!this._touching)
        return;

      requestAnimationFrame(this.update);

      const translateX = Math.min(0, this._currentX - this._startX + this._left);
      this.containerEl.style.transform = `translateX(${translateX}px)`;
    }
  });

  window.addEventListener('load', function() {
    var canvasElement = document.getElementById('glCanvas');
    canvasElement.setAttribute('width', window.innerWidth);
    canvasElement.setAttribute('height', window.innerHeight);

    var headingElement = document.getElementById('headingReading');
    var titleElement = document.getElementById('title');

    new Compass(canvasElement, headingElement, titleElement);
  }, true);

</script>
</head>

<body>
  <menu-drawer style="z-index: 1">
    <div style="display: flex; flex-direction: column">
      <button>Accelerometer</button>
      <button>Gyroscope</button>
      <button>Magnetometer</button>
      <button>Complementary filter (accel + gyro)</button>
      <button>Kalman filter (accel + gyro)</button>
    </div>
  </menu-drawer>
  <div class="heading"><span id="headingReading">-</span>&deg;</div>
  <div class="heading" id="title"></div>
  <canvas id="glCanvas" width="320" height="240"></canvas>
</body>

</html>
